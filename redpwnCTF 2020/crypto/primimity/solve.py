import math
import decimal
from Crypto.Util.number import inverse, isPrime
decimal.getcontext().prec = 1000

# we need to use the decimal library for the cube root since
# n is too big/precise for floats
n = decimal.Decimal(2739699434633097765008468371124644741923408864896396205946954196101304653772173210372608955799251139999322976228678445908704975780068946332615022064030241384638601426716056067126300711933438732265846838735860353259574129074615298010047322960704972157930663061480726566962254887144927753449042590678730779046154516549667611603792754880414526688217305247008627664864637891883902537649625488225238118503996674292057904635593729208703096877231276911845233833770015093213639131244386867600956112884383105437861665666273910566732634878464610789895607273567372933766243229798663389032807187003756226177111720510187664096691560511459141773632683383938152396711991246874813205614169161561906148974478519987935950318569760474249427787310865749167740917232799538099494710964837536211535351200520324575676987080484141561336505103872809932354748531675934527453231255132361489570816639925234935907741385330442961877410196615649696508210921)
cbrt = int(math.ceil(n**(decimal.Decimal(1)/decimal.Decimal(3))))
# we are just using this as a reference point,
# not needing the exact cube root, so keep it odd
if cbrt % 2 == 0:
    print("added 1 to cbrt")
    cbrt += 1
print(cbrt, isPrime(cbrt))

def find_next_prime_ascending(n):
    while not isPrime(n):
        n += 2
    return n
def find_next_prime_descending(n):
    while not isPrime(n):
        n -= 2
    return n

# there's no way we'll need to step 520 away from the cube root,
# because if all 3 numbers are below the root (which is only
# 2*256 = 512, not even 520), their product would certainly
# be below n, and same for if they were all higher
reach = 520
factors = []
divide_check = 2739699434633097765008468371124644741923408864896396205946954196101304653772173210372608955799251139999322976228678445908704975780068946332615022064030241384638601426716056067126300711933438732265846838735860353259574129074615298010047322960704972157930663061480726566962254887144927753449042590678730779046154516549667611603792754880414526688217305247008627664864637891883902537649625488225238118503996674292057904635593729208703096877231276911845233833770015093213639131244386867600956112884383105437861665666273910566732634878464610789895607273567372933766243229798663389032807187003756226177111720510187664096691560511459141773632683383938152396711991246874813205614169161561906148974478519987935950318569760474249427787310865749167740917232799538099494710964837536211535351200520324575676987080484141561336505103872809932354748531675934527453231255132361489570816639925234935907741385330442961877410196615649696508210921

# takes about 3 minutes to run for me...
last_descending = cbrt
last_ascending = cbrt
for _ in range(reach):
    if _ % 5 == 0:
        print(_)

    last_descending = find_next_prime_descending(last_descending)
    last_ascending = find_next_prime_ascending(last_ascending)

    if divide_check % last_descending == 0:
        factors.append(last_descending)
        divide_check //= last_descending
        print(last_descending)
        if len(factors) == 2:
            break
    if divide_check % last_ascending == 0:
        factors.append(last_ascending)
        divide_check //= last_ascending
        print(last_ascending)
        if len(factors) == 2:
            break

    last_descending -= 2
    last_ascending += 2

factors.append(divide_check)

print(factors)

# decrypt the rsa now that we know the factors

p, q, r = factors
n = 2739699434633097765008468371124644741923408864896396205946954196101304653772173210372608955799251139999322976228678445908704975780068946332615022064030241384638601426716056067126300711933438732265846838735860353259574129074615298010047322960704972157930663061480726566962254887144927753449042590678730779046154516549667611603792754880414526688217305247008627664864637891883902537649625488225238118503996674292057904635593729208703096877231276911845233833770015093213639131244386867600956112884383105437861665666273910566732634878464610789895607273567372933766243229798663389032807187003756226177111720510187664096691560511459141773632683383938152396711991246874813205614169161561906148974478519987935950318569760474249427787310865749167740917232799538099494710964837536211535351200520324575676987080484141561336505103872809932354748531675934527453231255132361489570816639925234935907741385330442961877410196615649696508210921
e = 65537
c = 2082926013138674164997791605512226759362824531322433048281306983526001801581956788909408046338065370689701410862433705395338736589120086871506362760060657440410056869674907314204346790554619655855805666327905912762300412323371126871463045993946331927129882715778396764969311565407104426500284824495461252591576672989633930916837016411523983491364869137945678029616541477271287052575817523864089061675401543733151180624855361245733039022140321494471318934716652758163593956711915212195328671373739342124211743835858897895276513396783328942978903764790088495033176253777832808572717335076829539988337505582696026111326821783912902713222712310343791755341823415393931813610365987465739339849380173805882522026704474308541271732478035913770922189429089852921985416202844838873352090355685075965831663443962706473737852392107876993485163981653038588544562512597409585410384189546449890975409183661424334789750460016306977673969147

d = inverse(e, (p-1)*(q-1)*(r-1))
message = pow(c, d, n)

message = bin(message)[2:]

print("".join(
    [chr(int(message[i:i+7], 2)) for i in range(0, len(message), 8)]
))
